# 비트마스크(with kotlin)

비트마스크를 활용하여 알고리즘 문제를 효과적으로 푸는 방법을 접하게 되었습니다. 왜 사용하고 어떻게 하면 저도 활용할 수 있을지 고민했습니다.

## 비트마스크를 사용하여 더 작은 메모리를 사용

- bit가 10개인 경우에는 각 bit당 두 가지 경우를 가지기 때문에 2^10가지의 경우를 10bit 이진수 하나로 표현이 가능합니다.
- 하나의 정수로 매우 많은 경우의 수를 표현할 수 있기 때문에 메모리 측면에서 효율적입니다.
- 더 많은 데이터를 미리 계산해서 저장해 둘 수 있는 장점이 있습니다.

## 비트마스크를 이용한 집합 구현

- 하나의 bit가 하나의 데이터 상태를 의미합니다.
- bit가 1이면 해당 원소가 집합에 포함되어 있다는 의미이고, 0이면 포함되어 있지 않다는 의미입니다.
- N비트는 N개의 원소를 갖는 집합의 부분집합들을 모두 표현합니다.

비트마스크 기법을 사용하는 방법은 다음과 같습니다.

- **원소 표현**: 원소는 이진수의 각 비트를 사용하여 표현됩니다. 예를 들어, 0번째 비트는 원소 A, 1번째 비트는 원소 B, 2번째 비트는 원소 C 등으로 표현할 수 있습니다.

- **집합 표현**: 원소들의 집합은 이진수로 표현됩니다. 예를 들어, 원소 A와 C가 있는 집합은 이진수 101로 표현할 수 있습니다.

- **원소 추가**: 원소를 추가하려면 OR 연산(|)을 사용합니다. 예를 들어, 원소 B를 추가하려면 101 | (1 << 1) = 101 | 010 = 111과 같이 계산할 수 있습니다.

- **원소 삭제**: 원소를 삭제하려면 AND 연산(&)과 NOT 연산(~)을 사용합니다. 예를 들어, 원소 C를 삭제하려면 111 & ~(1 << 2) = 111 & 011 = 011과 같이 계산할 수 있습니다.

- **원소 조회**: 원소의 존재 여부를 확인하려면 AND 연산(&)을 사용합니다. 예를 들어, 원소 B가 있는지 확인하려면 011 & (1 << 1) = 011 & 010 = 010이고, 결과가 0이 아니므로
  원소 B가 있다고 판단할 수 있습니다.

- **원소 토글**: 원소의 존재 여부를 반대로 바꾸려면 XOR 연산(^)을 사용합니다. 예를 들어, 원소 B의 존재 여부를 바꾸려면 011 ^ (1 << 1) = 011 ^ 010 = 001과 같이 계산할 수
  있습니다.

# 예시 문제들

다음은 응용할 수 있는 문제들입니다.
저의 경우 각 메서드에 중단점을 찍은 후, 디버깅을 하며 변수들이 어떻게 변화하는지를 관찰하며 이해했습니다.

## 문제 예시 1

- 각 사람은 0부터 N-1까지의 번호가 부여되어 있다.
- 짝을 지어줄 수 없는 경우는 없다고 가정한다.

### 문제:

N명의 사람이 참석한 파티에서, 서로 짝을 이루어 춤을 추려고 합니다.
가능한 모든 쌍의 조합을 찾으세요. 단, 각 사람은 한 번만 춤을 출 수 있으며, 한 쌍으로 짝 지어줄 수 있는 경우만 고려합니다.

입력:

- N (2 <= N <= 20, N은 짝수)

출력:

- 가능한 모든 쌍의 조합의 개수를 출력하세요.

예시:

```
입력: 4
출력: 3
```

설명:
가능한 쌍의 조합은 `(0, 1), (2, 3), (0, 2), (1, 3), (1, 2)` 총 6개이지만,
각 사람은 한 번만 춤을 출 수 있으므로 가능한 조합은
`{(0, 1), (2, 3)}`, `{(0, 2), (1, 3)}`, `{(0, 3), (1, 2)}` 총 3가지입니다.

### 풀이:

이 문제를 비트마스크를 활용하여 풀기 위해서는 각 사람의 짝 지어진 상태를 이진수로 표현할 수 있습니다. 예를 들어, 4명의 사람이 있을 때 각 비트가 사람의 짝 지어진 상태를 나타낸다면 다음과 같습니다.

- 0: 0000 (아무도 짝이 없음)
- 1: 0011 (0번과 1번이 짝)
- 2: 1100 (2번과 3번이 짝)
- 3: 0101 (1번과 2번이 짝)

비트마스크와 재귀함수를 활용하여 가능한 모든 조합을 찾아보겠습니다.

```kotlin
fun countPairs(n: Int, paired: Int): Int {
    // 기저 사례: 모든 사람이 짝을 이룬 경우
    if (paired == (1 shl n) - 1) {
        return 1
    }

    // 이미 짝이 있는 사람을 찾기 위해 사용
    var first = -1
    for (i in 0 until n) {
        if (paired and (1 shl i) == 0) {
            first = i
            break
        }
    }

    // 기저 사례: 모든 사람이 짝을 이룰 수 없는 경우
    if (first == -1) {
        return 0
    }

    var result = 0
    for (i in first + 1 until n) {
        // 짝이 없는 상태이고, i와 first가 짝이 될 수 있는 경우
        if (paired and (1 shl i) == 0) {
            // i와 first를 짝으로 만들고, 재귀 호출
            result += countPairs(n, paired or (1 shl i) or (1 shl first))
        }
    }
    return result
}

fun main() {
    val n = 4
    println(countPairs(n, 0)) // 출력: 3
}
```

## 문제 예시 2

여행자가 도시들을 순회하는 최소 비용을 구하는 TSP(Traveling Salesman Problem)를 살펴보겠습니다.

### 문제:

N개의 도시가 있고, 각 도시 간의 이동 비용이 주어집니다.
여행자는 한 도시에서 시작하여 모든 도시를 한 번씩 방문한 후 다시 시작 도시로 돌아와야 합니다.
최소 비용으로 모든 도시를 방문하는 경로를 찾으세요.

입력:

- N (3 <= N <= 16)
- 이동 비용 행렬 W (2차원 배열, `W[i][j]`는 도시 i에서 도시 j로 이동하는 비용, 1 <= `W[i][j]` <= 1,000,000, `W[i][i]` = 0)

출력:

- 최소 비용으로 모든 도시를 방문하는 경로의 비용을 출력하세요.

### 풀이:

이 문제는 비트마스크와 동적 계획법을 함께 활용해 해결할 수 있습니다.
비트마스크를 사용하여 방문한 도시들을 나타내고, 동적 계획법을 사용하여 중복 계산을 최소화하는 방식으로 문제를 해결할 수 있습니다.

```kotlin
const val MAX = 16
const val INF = 1_000_000_000
val W = Array(MAX) { IntArray(MAX) }
val dp = Array(MAX) { IntArray(1 shl MAX) { -1 } }

fun tsp(current: Int, visited: Int, n: Int): Int {
    if (visited == (1 shl n) - 1) {
        return if (W[current][0] != 0) W[current][0] else INF
    }

    if (dp[current][visited] != -1) {
        return dp[current][visited]
    }

    var minCost = INF
    for (next in 0 until n) {
        if (W[current][next] != 0 && (visited and (1 shl next)) == 0) {
            minCost = minOf(minCost, W[current][next] + tsp(next, visited or (1 shl next), n))
        }
    }

    dp[current][visited] = minCost
    return minCost
}

fun main() {
    val n = 4
    W[0] = intArrayOf(0, 10, 15, 20)
    W[1] = intArrayOf(5, 0, 9, 10)
    W[2] = intArrayOf(6, 13, 0, 12)
    W[3] = intArrayOf(8, 8, 9, 0)

    println(tsp(0, 1, n)) // 출력: 35
}
```

재귀 함수 `tsp`를 사용하며, 동적 계획법을 활용하여 중복 계산을 줄입니다. `dp` 배열은 도시와 방문한 도시들의 상태를 기록하여 이미 계산한 값을 재사용할 수 있게 합니다.

`tsp` 함수는 현재 위치(`current`), 방문한 도시들의 상태(`visited`), 도시의 개수(`n`)를 인자로 받습니다. 기저 사례로 모든 도시를 방문한 경우와 이미 계산한 결과를 재사용하는 경우를
처리합니다.

그리고, 다음 도시를 선택하며 이동할 수 있는 경우에 대해 최소 비용을 계산합니다. 비트마스크를 사용하여 방문한 도시들의 상태를 나타내고, 방문하지 않은 도시로 이동하며 최소 비용을 찾습니다.

이 예시에서는 도시의 개수가 4개이며, 각 도시 간의 이동 비용이 주어진 행렬로 표현되어 있습니다. 이를 활용하여 최소 비용으로 모든 도시를 방문하는 경로의 비용을 구하면 결과는 35가 됩니다.

도시 간 이동 비용:

```kotlin
0   10  15  20
5   0   9   10
6   13  0   12
8   8   9   0
```

여기서 도시 0에서 시작하여 모든 도시를 방문한 후 다시 도시 0으로 돌아와야 합니다. 이를 비트마스크와 동적 계획법을 사용하여 해결할 수 있습니다.

다음은 각 단계별로 비트마스크와 동적 계획법을 활용한 최소 비용 탐색 과정을 나타냅니다.

1. 시작: `tsp(0, 1, 4)`

- 현재 위치: 0
- 방문한 도시: 0 (비트마스크: 0001)
- 도시 개수: 4

2. 도시 1로 이동: `tsp(1, 3, 4)`

- 현재 위치: 1
- 방문한 도시: 0, 1 (비트마스크: 0011)
- 도시 개수: 4

3. 도시 2로 이동: `tsp(2, 7, 4)`

- 현재 위치: 2
- 방문한 도시: 0, 1, 2 (비트마스크: 0111)
- 도시 개수: 4

4. 도시 3으로 이동 및 완료: `tsp(3, 15, 4)`

- 현재 위치: 3
- 방문한 도시: 0, 1, 2, 3 (비트마스크: 1111)
- 도시 개수: 4

5. 최소 비용 계산

- 0 → 1: 비용 10
- 1 → 2: 비용 9
- 2 → 3: 비용 12
- 3 → 0: 비용 8
- 총 비용: 10 + 9 + 12 + 8 = 35
  이 과정을 통해 최소 비용으로 모든 도시를 방문하는 경로의 비용을 구할 수 있습니다. 여기서는 도시 0 → 1 → 2 → 3 → 0 순서로 방문하며 총 비용은 35가 됩니다.

## 예시 문제 3

전구 교체하기

### 문제:

- N개의 전구가 일렬로 나열되어 있습니다. 각 전구는 켜져 있거나 꺼져 있는 상태입니다.
- 전구를 교체할 때, 한 번에 최대 K개의 연속된 전구를 교체할 수 있습니다.
- 목표는 모든 전구를 켜진 상태로 만드는 것입니다.
- 전구를 교체하는 최소 횟수를 구하세요.

입력:

- N (1 <= N <= 10)
- K (1 <= K <= N)
- 전구의 초기 상태를 나타내는 길이 N의 문자열 (0: 꺼진 상태, 1: 켜진 상태)

출력:

- 모든 전구를 켜진 상태로 만드는 데 필요한 최소 교체 횟수를 출력하세요.

### 풀이:

이 문제는 비트마스크를 사용하여 전구의 상태를 나타낼 수 있으며, 시뮬레이션으로 교체 과정을 진행할 수 있습니다.

```kotlin
fun countSwitches(n: Int, k: Int, state: Int): Int {
    var switches = 0
    var current = state

    for (i in 0 until n) {
        if (current and (1 shl i) == 0) { // 전구가 꺼져 있는 경우
            if (i + k > n) { // K개의 연속된 전구를 교체할 수 없는 경우
                return -1
            }
            switches++
            for (j in i until i + k) {
                current = current xor (1 shl j) // 전구의 상태를 바꿈
            }
        }
    }
    return switches
}

fun main() {
    val n = 5
    val k = 2
    val initialState = "01001".toInt(2) // 꺼진 상태를 나타내는 문자열을 정수로 변환

    println(countSwitches(n, k, initialState)) // 출력: 2
}
```

이 코드에서는 countSwitches 함수를 사용하여 최소 교체 횟수를 계산합니다.
전구의 상태를 나타내는 문자열을 정수로 변환하여 비트마스크로 사용하고, 시뮬레이션을 통해 교체 과정을 진행합니다.
또한, K개의 연속된 전구를 교체할 수 없는 경우는 -1을 반환하여 해결할 수 없음을 표시합니다.

이 예시에서는 전구 5개가 있고, 한 번에 최대 2개의 연속된 전구를 교체할 수 있습니다.
초기 상태는 01001이며, 최소 2번의 교체를 통해 모든 전구를 켜진 상태로 만들 수 있습니다.

교체 과정은 다음과 같습니다.

1. 0번째와 1번째 전구를 교체

- 초기 상태: 01001 (비트마스크: 00101)
- 교체 후: 10011 (비트마스크: 01011)

2. 3번째와 4번째 전구를 교체

- 교체 전: 10011 (비트마스크: 01011)
- 교체 후: 11111 (비트마스크: 01111)

이렇게 두 번의 교체를 통해 모든 전구를 켜진 상태로 만들 수 있으므로, 출력 결과는 2가 됩니다.

## 참고 문제
BOJ 1562번: 계산 수
https://www.acmicpc.net/problem/1562